# How the CLI/CIL/CLR Flabbergast Compiler Works

Ignoring the lack of patience I have in deciding which of CIL, CLI, or CLR is appropriate, this compiler targets that platform. The compiler itself is written in C#, but generates CIL bytecode directly using `System.Reflection.Emit`. It is being developed on Mono and should work on .NET.

There are several components:

 - The Compiler Services, which knows how to transform source code into CIL bytecode.
 - The Runtime Services, which provide the extra bits and pieces needed to run Flabbergast programs on the CLR.
 - The Compiler, which uses Compiler Services to transform source into bytecode and write it to an assembly.
 - The Pre-Compiled Loader, which can be used by Runtime Services to load assemblies generated by the compiler at run time.
 - The Source Compiling Loader, which uses Compiler Services to compiles source files and hot load them into the CLR.

Most host programs will want to have the whole suite, but, in theory, a program could hold only the “runtime” aspects of the language.

You should read the compiler design document in the parent directory.

## Compiler Services

Like all compilers, Compiler Services has three steps: parse, analyse, and code generation. The code for all three has some human-written components, in `parser.cs`, `analyser.cs`, and `generator.cs`, respectively, and generated, using `lib:compiler` and `compiler-net.o_0` to build `compiler-net.cs`.

For parsing, a pack-rat parser is used. The patterns specified in `lib:compiler` will generate an LL(1) parser for the syntax of the language with extra steps to memorise values as parsing proceeds. `Flabbergast.Parser` has general parsing state and any error information for the parsing of one file. During the parsing process, many `Flabbergast.ParsingPosition` objects are created to track the state of parsing. Memorisation data is stored in `Parser` as `Memory` structures. All parsable objects descend from `Flabbergast.AstNode` which has properties for information about where the element was parsed, used in error message and debug information generation in later stages. The parser only stores a single error message: the sequentially furtherest error message discovered.

Analysis consists of two phases: splitting the program into _environments_ and type inference. An _environment_ is a context where variable lookups will always have the same value. Lookups require non-local program flow and are therefore slow. `Flabbergast.Type` holds the representation of each type, as a set of bit flags, and `Flabbergast.Environment` holds an environment. There are a collection of `Flabbergast.NameInfo` classes that store information about particular looked up names. The semantics are based on the relationship between the environments in which the names exist.
